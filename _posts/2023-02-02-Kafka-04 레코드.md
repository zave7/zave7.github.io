---
title: Kafka 레코드
categories: Kafka
---

# 레코드

### 1. 브로커에 한번 적재된 레코드는 수정할 수 없고 로그 리텐션 기간 또는 용량에 따라서만 삭제된다.
### 2. 레코드의 구성
1. ***timestamp - 타임스탬프***
    1. 레코드의 타임스탬프는 스트림 프로세싱에서 활용하기 위한 시간을 저장하는 용도로 사용된다.
    2. 카프카 0.10.0.0 이후 버전부터 추가된 타임스탬프는 Unix timestamp가 포함되며 프로듀서에서 따로 설정하지 않으면 기본값으로 RroducerRecord 생성 시간(create time) 이 들어간다.
    3. 또는 브로커 적재 시간(LogAppendTime)으로 설정할 수도 있다.
    4. 해당 옵션은 토픽 단위로 설정가능하며 message.timestamp.type 을 사용한다.
2. ***offset - 오프셋***
    1. 레코드의 오프셋은 프로듀서가 생성한 레코드에는 존재하지 않는다. 
    프로듀서가 전송한 레코드가 브로커에 적재될 때 오프셋이 지정된다.
    오프셋은 0부터 시작되고 1씩 증가한다.
    2. 컨슈머는 오프셋을 기반으로 처리가 완료된 데이터와 앞으로 처리해야할 데이터를 구분한다.
    3. 각 메세지는 파티션별로 고유한 오프셋을 가지므로 컨슈머에서 중복처리를 방지하기 위한 목적으로도 사용된다.
3. ***headers - 헤더***
    1. 레코드의 헤더는 0.11부터 제공된 기능이다.
    2. key/value 데이터를 추가할 수 있으며 레코드의 스키마 버전이나 포맷과 같이 데이터 프로세싱에 참고할만한 정보를 담아서 사용할 수 있다.
4. ***key - 메세지 키***
    1. 메세지 키는 처리하고자 하는 메세지의 값의 분류하기 위한 용도로 사용되며, 이를 파티셔닝이라고 부른다.
    2. 파티셔닝에 사용하는 메세지키는 파티셔너(Partitionor)에 따라 토픽의 파티션 번호가 정해진다. 메세지 키는 필수 값이 아니며, 지정하지 않으면 null 로 설정된다. 메세지 키가 null인 레코드는 특정 토픽의 파티션에 라운드 로빈으로 전달된다. null이 아닌 메세지 키는 해시값에 의해서 특정 파티션에 매핑되어 전달된다.
    3. 동일한 key를 같는 레코드는 항상 동일한 파티션에 할당된다. (처리 순서를 보장하기 위해 사용할 수도 있다)
5. ***value - 메세지 값***
    1. 레코드의 메세지 값은 실질적으로 처리할 데이터가 담기는 공간이다.
    2. 메세지 값의 포맷은 제네릭으로 사용자에 의해 지정된다. 다양한 형태로 지정 가능하며 필요에 따라 사용자 지정 포맷으로 직렬화/역질렬화 하여 사용할 수도 있다.
    3. 브로커에 저장된 레코드의 메세지 값은 어떤 포맷으로 직렬화되어 저장되었는지 알 수 없기 때문에 컨슈머는 미리 역직렬화 포맷을 알고 있어야 한다.